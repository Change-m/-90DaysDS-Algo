# Majority Elemnts in an array:
                               
                               Boyer-Moore majority Algorithm: to find the majority element in array we count
                               the frequency of every element but we are not sure about the ans, we check the ans 
                               in the end of the code by running simple code.
                               Example:- 
                                         arr = [1, 1, 2, 3, 1]
                                         start counting element   1 -->1 -->2 -->1 -->2
                                                                  2 -->1 -->0
                                                                  3 -->1 -->0
                                         after find the elemnt left in count is 1 with frequency 2
                                         Now, we will run a loop to check our ans is correct or not
                                         loop find 1 --> 3, count 3 1 is our ans.
                                         
                                         
                                def majorityElement( arr: int)
                                     ansIndex = 0
                                     count = 1
                                     for i in range(len(arr)):
                                         if arr[i] == arr[ansIndex]:
                                              count += 1
                                         else:
                                              count -= 1
                                         if count == 0:
                                             ansIndex = i
                                             count = 1
                                     for i in range(len(arr):    #Check if the ansIndex is actually the ans
                                         arr[i] == arr[ansIndex]
                                         count += 1
                                     if count == n/2:
                                         return arr[ansIndex]
                                         
             ----------------------------*************************Book Allocation***********************----------------------------------------------------------
             
             
Allocate minimum pages:- 
                       Minimise the maximum numbers of pages read by a students.
                       constraint :- book distribute in continue way and every student need to read the book by their own.
                                     not spliting book.
                       
                       Using Broute Force:- Time Complexity O (2^n)
                                            We divide the list in two parts and consider all the possibility to divide books between k numbers
                                            of students recursively.
                       
                       
                       Using Binary Search:- Time Complexity O (nlogn), Space Complexity O (1)
                                             Array is not sorted but we using binary search because we need to allocate book in continouse way.
                                             
                                             Example:-
                                                      a = [10, 5, 20]
                                                      
                                                      def minPages(a: List[int], k: int):
                                                           min = max(a)
                                                           max = sum(a)
                                                           res = 0
                                                           while (min <= max):
                                                                mid = (min + max)/2
                                                                if (isFesible(n, x, mid):
                                                                    res = mid
                                                                    max = mid - 1
                                                                 else:
                                                                      min = mid + 1
                                                           return res
                                                           
                                                      def isFeasible(a: List[int], k: int, res):
                                                            student = 1, sum = 0
                                                            for i in range(len(a)):
                                                                if sum + a[i] > res:
                                                                    student += 1
                                                                    sum = a[i]
                                                                else:
                                                                     sum += a[i]
                                                             return student <= k
                                                             
    -----------------------------------------------**************************** RainWater Trapping Problem *************************-----------------------------------------------


Rainwater Trapping Problem:- 
                            a = [3, 1, 2, 4, 0, 1, 3, 2]
                                  _
                            _    |_|    _
                           |_|  _|_|   |_|_
                           |_|_|_|_|  _|_|_|
                           |_|_|_|_| |_|_|_|
                  left -->  3,3,3,4,4,4,4,4   #checking from the left the max height of the block
                            4,4,4,4,3,3,3,2  <-- right    #checking from the right the max height of the block
                            
                            Formula:-  i = math.min(left[i], right[i]) - a[i]
                            # we are taking the min height from left or right and subtracting than from the element from the array.
                              which give the amount of water store above the block and we add all the water stored and it give total amount of water.
                              
      Using Space Approach:- Time Complexity:-  O (n),  Space Complexity:- O (n)
      
                            def rainWater(a: int):
                                 n = len(a)
                                 left = []
                                 right = []
                                 left[0] = a[0]
                                 for i in range(n):
                                     left[i] = math.max(left[i-1], a[i])
                                     
                                     right[n-1] = a[n-1]
                                 for i in range(n-2, 0):
                                     right[i] = math.max(right[i+], a[i]):
                                     
                                 ans = 0
                                 for i in range(n):
                                     ans += (math.min(left[i], right[i]) - a[i]
                                 return ans
                            
                                    
      Without Using Space Approach:- Time Complexity:-  O (n),  Space Complexity:- O (1)
                                    
                                    def trap(a: int):
                                        (left, right) = (0, len(a) - 1)
                                        water = 0
                                        maxLeft = a[left]
                                        maxRight = a[right]
                                        
                                        While left < right:
                                             if a[left] <= a[right]:
                                                 left = left + 1
                                                 maxLeft = max(maxLeft, a[left])
                                                 water += (maxLeft - a[left])
                                             else:
                                                  right = right - 1
                                                  maxRight = max(maxRight, a[right])
                                                  water += (maxRight - a[right])
                                        return water 
