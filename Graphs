Graphs:- 
        Representation of graphs are like Adjancey Matrix and Adjancey LinkedList
        
        Adjancey Matrix                                                     Adjancey LinkedList
        _ _ _ _                                                              _       _       _
       |_|_|_|_|                                                            |_| --> |_| --> |_|
       |_|_|_|_|                                                            |_| --> |_|
       |_|_|_|_|                                                            |_| --> |_| --> |_|
       |_|_|_|_|                                                            |_| --> |_|
       
   Used in - Dense Graphs(completely connected)                         Used in - Sparse Graphs(all the nodes are not connected)
   
   use Queue and Visited list for graphs
   
   ---------------------------------------------************** Breath First Search **************---------------------------------------------------
   Questions:-  
               1. Find the minimum distance from source to destination.
                  
                                      def (arr: List[List[int]]], src: int, dest: int, v: int, pred: List[int], dist: List[int]):
                                          queue = defaultdict{arr}
                                          bool visited= []
                                          for i in range(v):
                                              visited[i] = False
                                              dist[i] = Maxvalue
                                              pred[i] = -1   ### difining the source node to reach any node
                                          visited[src] = true  ### mark ture the src you visited 
                                          dist[src] = 0      ### the distance of the src from the src is 0
                                          queue.add(src)     ### add src to queue
                                          
                                          while (queue.isEmpty()):   ### after adding source the queue is not emmpty
                                               cur = queue.remove()
                                               for i in range(len(arr.get(u))):
                                                   neighbor = arr.get(u).get(i)    ### picking the element in the linkedlist to reach neighbor of the nodes
                                                   if visited[neighbor] == False:
                                                      visited[neighbor] = True
                                                      dist[neighbor] = dist[cur] + 1   ### after storing source every neighbor is 1 unit away
                                                      pred[neighbor] = cur
                                                      queue.add(neighbor)
                                                      if neighbor == dest:
                                                         return True
                                          return False
               
               
               2. Find the numbers of connected components-
                                                           When some connected componenets of the graph is not connected.
                                                           
                                                                   vis[] = boolean[v+1]
                                                                   pred[] = [v+1]
                                                                   dist[] = [v+1]
                                                                   
                                                                   components = 0
                                                                   for i in range(v):
                                                                       if !vis[i]:
                                                                          components += 1
                                                                          bfs(arr, 1, 6, v, pred, dist, vis):
               
                 
               
                  
    ----------------------------------------************************************* Depth First Search ******************************************-------------------------------------------------
    
    
    Depth First Search:-  
                        Go in depth in one direction.
                        Use stack not queue
                                      
                                      def dfsOfGraph(V: int, arr: dict{int}):
                                          vis = boolean([])
                                          ans = List[List[]]
                                          
                                          dfs(0, arr, vis, ans):
                                             return ans
                                             
                                      def dfs(arr: List[List[]], v: List[bool], ans: List[int]):
                                          vis[v] = True
                                          ans.add(v)
                                          for neighbor = arr.get(v):
                                              if (!vis[neighbor])
                                                  dfs(neighbor, arr, vis, ans)
                        
                        
                        
                         Find the number of connected components:
                                                                 for i in range(v):
                                                                    if !vis[i]:
                                                                       dfs(i, arr, vis, ans)
                         
                        
Questions:
          1. Detect cycle in an Undirected graph (DFS): O (V+E)
                                                       def isCycle(V: int, arr: List[List[int]]):
                                                           vis = List[bool]
                                                           for i in range(V):
                                                              if !vis[i]:
                                                                 if dfs(i, arr, vis, -1)) return True
                                                           return False
                                                       def dfs(v: int, arr: List[List[int]], vis: List[bool], parent: int):
                                                           vis[V] = True
                                                           for neighbor = arr.get(v):
                                                              if !vis[neighbor]:
                                                                 if dfs(neighbor, arr, vis, v):
                                                                    return True
                                                              else:
                                                                   if parent != neighbor:
                                                                   return True
                                                           return False
                                                         
                        
                        
                        
                        
                        
                        
